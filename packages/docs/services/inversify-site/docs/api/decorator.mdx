---
sidebar_position: 4
title: Decorator
---
import decoratorApiInjectConstructorArgumentSource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiInjectConstructorArgument.ts.txt';
import decoratorApiInjectPropertySource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiInjectProperty.ts.txt';
import decoratorApiMultiInjectPropertySource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiMultiInjectProperty.ts.txt';
import decoratorApiNamedSource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiNamed.ts.txt';
import decoratorApiOptionalSource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiOptional.ts.txt';
import decoratorApiPostConstructSource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiPostConstruct.ts.txt';
import decoratorApiPreDestroySource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiPreDestroy.ts.txt';
import decoratorApiTaggedSource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiTagged.ts.txt';
import decoratorApiUnmanagedSource from '@inversifyjs/code-examples/generated/examples/v7/decoratorApiUnmanaged.ts.txt';
import CodeBlock from '@theme/CodeBlock';

# Decorators

This section covers Inversify decorators used to provide class metadata.

## injectable

Decorator used to set class metadata so containers can receive class-emitted metadata.

It's highly recommended to annotate every class provided as a service with the `@injectable` decorator. However, it's not mandatory in every single case.

### When is injectable mandatory?

Whenever class-emitted metadata is expected.

Consider the following sample code:

```ts
import { injectable } from 'inversify';

@injectable()
class B {
  readonly foo: string = 'foo';
}

@injectable()
class A {
  constructor(public readonly b: B) {}
}
```

A CommonJS transpilation with the [emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata) option enabled might look like this:

```js
Object.defineProperty(exports, "__esModule", { value: true });
const inversify_1 = require("inversify");
let B = class B {
    foo = 'foo';
};
B = __decorate([
    (0, inversify_1.injectable)()
], B);
let A = class A {
    b;
    constructor(b) {
        this.b = b;
    }
};
A = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [B])
], A);
```

TypeScript emits class metadata if and only if there are any class decorators applied to the target class. If we remove the `@injectable` from `A`, the transpiled code looks very different:

```js
Object.defineProperty(exports, "__esModule", { value: true });
class B {
    foo = 'foo';
}
class A {
    b;
    constructor(b) {
        this.b = b;
    }
}
```

This time, no class metadata is emitted even if the `emitDecoratorMetadata` TypeScript option is enabled, causing trouble at execution time.

## inject

Decorator used to establish a relation between a constructor argument or a class property and a service ID.

When resolving an instance of the class, the target constructor argument or property will be resolved in the same way [container.get](/docs/api/container#get) behaves.

### Example: decorating a class constructor argument

<CodeBlock language="ts">{decoratorApiInjectConstructorArgumentSource}</CodeBlock>

### Example: decorating a property

<CodeBlock language="ts">{decoratorApiInjectPropertySource}</CodeBlock>

## multiInject

Decorator used to establish a relation between a constructor argument or a class property and a service ID.

When resolving an instance of the class, the target constructor argument or property will be resolved in the same way [container.getAll](/docs/api/container#getall) behaves.

### Example: decorating a property

<CodeBlock language="ts">{decoratorApiMultiInjectPropertySource}</CodeBlock>

## named

Decorator used to establish a relation between a constructor argument or a class property and a metadata name.

<CodeBlock language="ts">{decoratorApiNamedSource}</CodeBlock>

## optional

Decorator used to establish that a target constructor argument or property is optional and, therefore, it shall not be resolved if no bindings are found for the associated service ID.

<CodeBlock language="ts">{decoratorApiOptionalSource}</CodeBlock>

## postConstruct

Decorator used to establish an activation handler for the target class. Refer to the [docs](/docs/fundamentals/lifecycle/activation) for more information.

<CodeBlock language="ts">{decoratorApiPostConstructSource}</CodeBlock>

## preDestroy

Decorator used to establish a deactivation handler for the target class. Refer to the [docs](/docs/fundamentals/lifecycle/deactivation) for more information.

<CodeBlock language="ts">{decoratorApiPreDestroySource}</CodeBlock>

## tagged

Decorator used to establish a relation between a constructor argument or a class property and a metadata tag.

<CodeBlock language="ts">{decoratorApiTaggedSource}</CodeBlock>

## unmanaged

Decorator used to establish that Inversify should not inject the target constructor argument or property whatsoever.

<CodeBlock language="ts">{decoratorApiUnmanagedSource}</CodeBlock>
